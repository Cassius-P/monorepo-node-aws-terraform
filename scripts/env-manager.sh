#!/bin/bash

# Environment Variable Manager for AWS Systems Manager Parameter Store
# This script parses .env.example files and retrieves corresponding values from AWS SSM

set -e

# Configuration
DEFAULT_ENVIRONMENT="prod"
DEFAULT_APP_PREFIX=""
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Usage function
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -a, --app APP_NAME        Application name (required)"
    echo "  -e, --env ENVIRONMENT     Environment (default: prod)"
    echo "  -p, --prefix PREFIX       SSM parameter prefix (default: none)"
    echo "  -f, --format FORMAT       Output format: env-file|export|json (default: env-file)"
    echo "  -o, --output OUTPUT       Output file path (default: .env in app directory)"
    echo "  -v, --validate           Validate all parameters exist without creating output"
    echo "  -h, --help               Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -a api                                   # Create .env file for api app"
    echo "  $0 -a api -e staging -f export             # Export environment variables for staging"
    echo "  $0 -a api -v                               # Validate all parameters exist"
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if AWS CLI is available
check_aws_cli() {
    if ! command -v aws &> /dev/null; then
        log_error "AWS CLI is not installed or not in PATH"
        exit 1
    fi
}

# Check if jq is available for JSON processing
check_jq() {
    if ! command -v jq &> /dev/null; then
        log_warning "jq is not installed. JSON output format will not be available"
        return 1
    fi
    return 0
}

# Parse .env.example file and extract variable names
parse_env_example() {
    local env_example_file="$1"
    
    if [[ ! -f "$env_example_file" ]]; then
        log_error ".env.example file not found: $env_example_file"
        exit 1
    fi
    
    # Extract variable names (lines that don't start with # and contain =)
    grep -E '^[A-Za-z_][A-Za-z0-9_]*=' "$env_example_file" | cut -d'=' -f1
}

# Get parameter from AWS SSM Parameter Store
get_ssm_parameter() {
    local parameter_path="$1"
    local parameter_value
    
    parameter_value=$(aws ssm get-parameter --name "$parameter_path" --with-decryption --query 'Parameter.Value' --output text 2>/dev/null)
    
    if [[ $? -eq 0 ]]; then
        echo "$parameter_value"
        return 0
    else
        return 1
    fi
}

# Generate .env file
generate_env_file() {
    local app_name="$1"
    local environment="$2"
    local prefix="$3"
    local output_file="$4"
    local env_example_file="$5"
    
    log_info "Generating .env file for $app_name ($environment)"
    
    # Create output directory if it doesn't exist
    mkdir -p "$(dirname "$output_file")"
    
    # Clear output file
    > "$output_file"
    
    # Add header
    echo "# Generated by env-manager.sh on $(date)" >> "$output_file"
    echo "# Environment: $environment" >> "$output_file"
    echo "# Application: $app_name" >> "$output_file"
    echo "" >> "$output_file"
    
    local missing_params=()
    local found_params=()
    
    # Process each variable from .env.example
    while IFS= read -r var_name; do
        local parameter_path="/$environment/$app_name/$var_name"
        local parameter_value
        
        parameter_value=$(get_ssm_parameter "$parameter_path")
        
        if [[ $? -eq 0 ]]; then
            echo "$var_name=$parameter_value" >> "$output_file"
            found_params+=("$var_name")
            log_info "✓ Retrieved $var_name"
        else
            missing_params+=("$var_name")
            log_warning "✗ Missing parameter: $parameter_path"
        fi
    done < <(parse_env_example "$env_example_file")
    
    # Set file permissions
    chmod 600 "$output_file"
    
    # Report results
    log_success "Generated .env file: $output_file"
    log_info "Found parameters: ${#found_params[@]}"
    
    if [[ ${#missing_params[@]} -gt 0 ]]; then
        log_warning "Missing parameters: ${#missing_params[@]}"
        log_warning "Missing: ${missing_params[*]}"
        return 1
    fi
    
    return 0
}

# Generate export statements
generate_export_statements() {
    local app_name="$1"
    local environment="$2"
    local prefix="$3"
    local env_example_file="$4"
    
    log_info "Generating export statements for $app_name ($environment)"
    
    local missing_params=()
    
    # Process each variable from .env.example
    while IFS= read -r var_name; do
        local parameter_path="/$environment/$app_name/$var_name"
        local parameter_value
        
        parameter_value=$(get_ssm_parameter "$parameter_path")
        
        if [[ $? -eq 0 ]]; then
            echo "export $var_name=\"$parameter_value\""
        else
            missing_params+=("$var_name")
            log_warning "✗ Missing parameter: $parameter_path" >&2
        fi
    done < <(parse_env_example "$env_example_file")
    
    if [[ ${#missing_params[@]} -gt 0 ]]; then
        log_warning "Missing parameters: ${missing_params[*]}" >&2
        return 1
    fi
    
    return 0
}

# Validate all parameters exist
validate_parameters() {
    local app_name="$1"
    local environment="$2"
    local prefix="$3"
    local env_example_file="$4"
    
    log_info "Validating parameters for $app_name ($environment)"
    
    local missing_params=()
    local found_params=()
    
    # Process each variable from .env.example
    while IFS= read -r var_name; do
        local parameter_path="/$environment/$app_name/$var_name"
        
        if get_ssm_parameter "$parameter_path" > /dev/null; then
            found_params+=("$var_name")
            log_info "✓ $var_name"
        else
            missing_params+=("$var_name")
            log_warning "✗ $var_name (missing: $parameter_path)"
        fi
    done < <(parse_env_example "$env_example_file")
    
    # Report results
    log_info "Validation complete"
    log_success "Found parameters: ${#found_params[@]}"
    
    if [[ ${#missing_params[@]} -gt 0 ]]; then
        log_error "Missing parameters: ${#missing_params[@]}"
        log_error "Please create these parameters in AWS Systems Manager:"
        for param in "${missing_params[@]}"; do
            echo "  aws ssm put-parameter --name \"/$environment/$app_name/$param\" --value \"<value>\" --type String"
        done
        return 1
    fi
    
    log_success "All parameters are available!"
    return 0
}

# Main function
main() {
    local app_name=""
    local environment="$DEFAULT_ENVIRONMENT"
    local prefix="$DEFAULT_APP_PREFIX"
    local format="env-file"
    local output_file=""
    local validate_only=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -a|--app)
                app_name="$2"
                shift 2
                ;;
            -e|--env)
                environment="$2"
                shift 2
                ;;
            -p|--prefix)
                prefix="$2"
                shift 2
                ;;
            -f|--format)
                format="$2"
                shift 2
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -v|--validate)
                validate_only=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$app_name" ]]; then
        log_error "Application name is required"
        usage
        exit 1
    fi
    
    # Check dependencies
    check_aws_cli
    
    if [[ "$format" == "json" ]] && ! check_jq; then
        log_error "jq is required for JSON output format"
        exit 1
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" && "$format" == "env-file" ]]; then
        # Check if we're in deployment context (app directory) or monorepo context
        if [[ -f "$PROJECT_ROOT/.env.example" ]]; then
            # Deployment context: .env file goes in the app root
            output_file="$PROJECT_ROOT/.env"
        else
            # Monorepo context: .env file goes in apps/$app_name/
            output_file="$PROJECT_ROOT/apps/$app_name/.env"
        fi
    fi
    
    # Find .env.example file
    # Check if we're in deployment context (app directory) or monorepo context
    if [[ -f "$PROJECT_ROOT/.env.example" ]]; then
        # Deployment context: .env.example is in the app root
        local env_example_file="$PROJECT_ROOT/.env.example"
    else
        # Monorepo context: .env.example is in apps/$app_name/
        local env_example_file="$PROJECT_ROOT/apps/$app_name/.env.example"
    fi
    
    if [[ ! -f "$env_example_file" ]]; then
        log_error ".env.example file not found: $env_example_file"
        exit 1
    fi
    
    # Execute based on mode
    if [[ "$validate_only" == true ]]; then
        validate_parameters "$app_name" "$environment" "$prefix" "$env_example_file"
    elif [[ "$format" == "env-file" ]]; then
        generate_env_file "$app_name" "$environment" "$prefix" "$output_file" "$env_example_file"
    elif [[ "$format" == "export" ]]; then
        generate_export_statements "$app_name" "$environment" "$prefix" "$env_example_file"
    else
        log_error "Unsupported format: $format"
        exit 1
    fi
}

# Run main function with all arguments
main "$@"